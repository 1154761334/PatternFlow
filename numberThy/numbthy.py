# -*- coding: utf-8 -*-
"""numbthy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zFKorJ2XnXpkVGIpU5_XedMlU4y8SN7s
"""

import tensorflow as tf
import functools
sess = tf.InteractiveSession()
tf.global_variables_initializer()

####################-- gcd function --################

def gcd(a,b):
    '''gcd(a,b) return the greatest common divisor 
    of tensor constant a and b.'''
    a = tf.math.abs(a)
    b = tf.math.abs(b)
    result = tf.while_loop(
        cond,body,[a,b]
    )
    return result[1]
def cond(a,b):
    return tf.math.greater(a, 0)
def body(a,b):
    b = tf.math.floormod(b,a)
    tep = a
    a = b
    b = tep
    return a, b

a1 = tf.constant(2040)
b2 = tf.constant(1071)
h = gcd(a1,b2)


print (h.eval())

####################-- xgcd function --################

def xgcd(a,b):
    """xgcd(a,b) returns a tuple of form (g,x,y), where g is gcd(a,b) and
    x,y satisfy the equation g = ax + by."""
    a1=1; b1=0; a2=0; b2=1; aneg=1; bneg=1; flag=1
    a, aneg = tf.cond(tf.less(a, 0),true_fn= lambda: (tf.math.negative(a), -1), false_fn=lambda:(a, aneg))
    b, bneg = tf.cond(tf.less(b, 0),true_fn=lambda: (tf.math.negative(b), -1), false_fn=lambda:(b, bneg))
    
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.while_loop(
        lambda a,b,a1,b1,a2,b2,aneg,bneg,flag: tf.greater(flag,0),
        body_1,
        [a,b,a1,b1,a2,b2,aneg,bneg,flag]
    )
    res1, res2, res3 = tf.cond(
        tf.math.equal(a, 0),
        true_fn = lambda: (tf.identity(b), tf.math.multiply(a2,aneg), tf.math.multiply(b2,bneg)),
        false_fn = lambda: (tf.identity(a), tf.math.multiply(a1,aneg), tf.math.multiply(b1,bneg))
    )
    return res1, res2, res3

def body_1(a,b,a1,b1,a2,b2,aneg,bneg,flag): 
    quot = tf.math.negative(tf.math.floordiv(a,b))
    a = tf.math.floormod(a, b)
    a1 = tf.math.add(a1, tf.math.multiply(quot,a2))
    b1 = tf.math.add(b1, tf.math.multiply(quot,b2))
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.cond(
        tf.math.equal(a, 0),
        true_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,0),
        false_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,flag)
    )
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.cond(
        tf.math.not_equal(a,0),
        true_fn = lambda: body_2(a,b,a1,b1,a2,b2,aneg,bneg,flag),
        false_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,flag)
    )
    return a,b,a1,b1,a2,b2,aneg,bneg,flag
    
def body_2(a,b,a1,b1,a2,b2,aneg,bneg,flag):
    quot = tf.math.negative(tf.math.floordiv(b,a))
    b = tf.math.floormod(b, a)
    a2 = tf.math.add(a2, tf.math.multiply(quot,a1))
    b2 = tf.math.add(b2, tf.math.multiply(quot,b1))
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.cond(
        tf.math.equal(b, 0),
        true_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,0),
        false_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,flag)
    )
    return a,b,a1,b1,a2,b2,aneg,bneg,flag

a1 = tf.constant(65)
b2 = tf.constant(78)
a1 = tf.constant(4)
b2 = tf.constant(2)
h,v,f = xgcd(a1,b2)
print(h.eval(),v.eval(),f.eval())

l = tf.bitwise.right_shift(3,1)
print(l.eval())
p = ((4>>1) & 1)
print(p)
j = tf.bitwise.bitwise_and(2,9)
print(j.eval())

####################-- power_mod function --################

def power_mod(b,e,n):
    accum,i,bpow2 = tf.cond(
        tf.math.less(e,0),
        true_fn = lambda: (inverse_mod(b, n), tf.math.negative(e), n),
        false_fn = lambda: con_body(b,e,n)
    )
    return accum

def con_body(b,e,n):
    accum = 1; i = 0; bpow2 = b
    b,e,n,accum,i,bpow2 = tf.while_loop(
        lambda b,e,n,accum,i,bpow2: tf.greater(tf.bitwise.right_shift(e,i),0),
        while_body_,
        [b,e,n,accum,i,bpow2]
    )
    return accum,i,bpow2

def while_body_(b,e,n,accum,i,bpow2):
    b,e,n,accum,i,bpow2 = tf.cond(
        tf.math.equal(tf.bitwise.bitwise_and(tf.bitwise.right_shift(e,i),1),1),
        true_fn = lambda: con_body_1(b,e,n,accum,i,bpow2),
        false_fn = lambda: (b,e,n,accum,i,bpow2)
    )
    bpow2 = tf.math.floormod(tf.math.multiply(bpow2,bpow2),n)
    i = tf.math.add(i,1)
    return b,e,n,accum,i,bpow2

def con_body_1(b,e,n,accum,i,bpow2):
    accum = tf.math.floormod(tf.math.multiply(accum,bpow2),n)
    return b,e,n,accum,i,bpow2

####################-- inverse_mod function --################

def inverse_mod(a,n):
    (g,xa,xb) = xgcd(a,n)
    result = tf.cond(
        tf.math.not_equal(g,1),
        true_fn = lambda: -1,
        false_fn = lambda: tf.math.floormod(xa,n)
    )
    return result

a = inverse_mod(4,7)
print(a.eval())

print(power_mod(4,3,2).eval())
print(power_mod(4,7,9).eval())

print(power_mod(1,6,4).eval())
print(power_mod(9,15,3).eval())

####################-- is_prime function --################

def is_prime(n):
    result = 1; 
    n = tf.cond(tf.math.less(n,0), lambda:tf.math.negative(n), lambda: n)
    result = tf.cond(
        tf.math.less(n,2), 
        lambda: tf.math.subtract(result,1), 
        lambda :is_prime_cond_body(n)
        )
    result = tf.math.equal(result, 1)
    return result

def is_prime_cond_body(n):
    check_list = tf.math.equal(n,(2,3,5,7,11,13,17,19,23,29))
    has_true, id_check_list = tf.unique(check_list)
    size = tf.size(has_true)
    result = tf.cond(tf.math.equal(size,2), lambda: 1, lambda: check_isprimeE(n))
    return result
    
def check_isprimeE(n):
    result = tf.logical_and(tf.logical_and(isprimeE(n,2), isprimeE(n,3)),isprimeE(n,5))
    result = tf.cond(tf.math.equal(result, True),lambda:1, lambda:0)
    return result

print(is_prime(2).eval())
print(is_prime(15).eval())
print(is_prime(27).eval())

####################-- factor function --################

@tf.function
def factor(n):
	"""factor(n) - Return a sorted list of the prime factors of n with exponents."""
	# Rewritten to align with SAGE.  Previous semantics available as factors(n).
	if ((abs(n) == 1) or (n == 0)): raise ValueError('Unable to factor {0}'.format(n))
	factspow = []
	currfact = None
	for thefact in factors(n):
		if thefact != currfact:
			if currfact != None:
				factspow += [(currfact,thecount)]
			currfact = thefact
			thecount = 1
		else:
			thecount += 1
	factspow += [(thefact,thecount)]
	return tuple(factspow)

print(factor(6)[0][0].eval())

####################-- prime_divisors function --################

def prime_divisors(n):
    return tuple(set(factors(n)))

####################-- euler_phi function --################

def euler_phi(n):
    n = tf.cond(tf.math.less_equal(n,0),lambda:0,lambda:n)
    n = tf.cond(tf.math.equal(n,1),lambda:1,lambda:n)
    return functools.reduce(lambda a,x:tf.math.multiply(tf.math.multiply(a,tf.math.pow(x[0],tf.math.subtract(x[1],1))),tf.math.multiply(tf.math.subtract(x[0],1))),factor(n),1)



print(euler_phi(4))

####################-- prime_divisors function --################

################ Internally used functions #########################################

####################-- isprimeF function --################

def isprimeF(n,b):
    """
    isprimeF(n,b) - Test whether number n is prime or a Fermat pseudoprime to base b.
    process: (b**(n-1)) % n
    """
    num = tf.math.floormod(tf.math.pow(b, n-1),n)
    return tf.math.equal(num,1)

a = isprimeF(25,3)
print(a.eval())
l = isprimeF(3,4)
print(l.eval())

####################-- isprimeE function --################

def isprimeE(n,b):
    result = 1; flag = 1; c = 0
    n,b,c,result,flag =  tf.cond(
        tf.math.logical_not(isprimeF(n,b)), 
        lambda:(n,b,c,0,flag), 
        lambda:cond_body(n,b,c,result,flag)
        )
    result = tf.math.equal(result, 1)
    return result

def cond_body(n,b,c,result,flag):
    r = tf.math.subtract(n,1)
    r = tf.while_loop(lambda r: tf.math.equal(tf.math.floormod(r,2), 0),
                      lambda r:tf.math.floordiv(r,2),
                      [r])
    c = tf.math.floormod(tf.math.pow(b, r),n)
    n,b,c,result,flag = tf.cond(
        tf.math.equal(c, 1), 
        true_fn = lambda:(n,b,c,1,flag), 
        false_fn = lambda: while_loop(n,b,c,result,flag)
        )
    return n,b,c,result,flag

def while_loop(n,b,c,result,flag):
    n,b,c,result,flag = tf.while_loop(
        lambda n,b,c,result,flag: tf.greater(flag,0),
        while_body,
        [n,b,c,result,flag]
    )
    return n,b,c,result,flag

def while_body(n,b,c,result,flag):
    n,b,c,result,flag = tf.cond(
        tf.math.equal(c,1),
        true_fn = lambda: (n,b,c,0,0),
        false_fn = lambda: while_body_1(n,b,c,result,flag)
        )
    return n,b,c,result,flag

def while_body_1(n,b,c,result,flag):
    n,b,c,result,flag = tf.cond(
        tf.math.equal(c,n-1),
        true_fn = lambda: (n,b,c,1,0),
        false_fn = lambda: (n,b,(tf.math.floormod(tf.math.pow(c, 2),n)),result,flag)
        )
    return n,b,c,result,flag

a = isprimeE(25,3)
print(a.eval())
a = isprimeE(15,4)
print(a.eval())
a = isprimeE(3,4)
print(a.eval())

####################-- factorone function --################

def factorone(n):
    fact = -1
    n, fact= tf.cond(is_prime(n), lambda:(n, n), lambda:factorone_cond_body(n,fact))
    fact = tf.cond(tf.math.equal(0,tf.math.mod(n,fact)),lambda:fact,lambda:factorPR(n))
    return fact

def factorone_cond_body(n,fact):
    fact_list = [2,3,5,7,11,13,17,19,23,29]
    size = len(fact_list)
    index = 0
    n,fact,index,size,fact_list = tf.while_loop(
        lambda n,fact,index,size,fact_list: tf.math.less(index,10),
        factorone_while_body,
        [n,fact,index,size,fact_list]
        )
    return n,fact
    
def factorone_while_body(n,fact,index,size,fact_list):
    n,fact,index,size,fact_list = tf.cond(
        tf.math.equal(tf.math.mod(n,tf.gather(fact_list,index)),0),
        lambda: (n,tf.gather(fact_list,index),size,size,fact_list),
        lambda: (n,fact,tf.math.add(index,1),size,fact_list)
        )
    return n,fact,index,size,fact_list

print(factorone(75).eval())

####################-- factors function --################

@tf.function
def factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

print(factors(4))
print()
l = prime_factors(56)
print(l)
print(l[0].eval())
print(l[1].eval())
print(l[2].eval())
print(l[3].eval())

fact = [-1];
fact =tf.convert_to_tensor(fact,tf.int32)
a = [fact]+[[tf.constant(5)]]+[[tf.constant(4)]]
a = tf.convert_to_tensor(a)
print(a.shape)
a = tf.reshape(a,[1,3])
print(a.eval())

a = tf.tuple([1,6,5])
b = tf.tuple([9])
c = a+b
c = tf.sort(c)
#print(c[0].eval())
#print(c[1].eval())
#print(c[2].eval())
#print(c[3].eval())
print(c.eval())

####################-- factorPR function --################

def factorPR(n):
    numsteps = tf.math.multiply(2.,tf.math.floor(tf.math.sqrt(tf.math.sqrt(tf.dtypes.cast(n,tf.float32)))))
    numsteps = tf.dtypes.cast(numsteps,tf.int32)
    additive = 1; g = -1; result = 0;
    n,numsteps,additive,g = tf.while_loop(
        lambda n,numsteps,additive,g: tf.math.less(additive,5),
        factorPR_while_body,
        [n,numsteps,additive,g]
    )
    result = tf.cond(tf.math.equal(additive,4),lambda:1,lambda:g)
    return result

def factorPR_while_body(n,numsteps,additive,g):
    fast=slow=1; i=1; 
    n,numsteps,fast,slow,i,additive,g = tf.while_loop(
        lambda n,numsteps,fast,slow,i,additive,g: tf.math.less(i,numsteps),
        inside_while_body,
        [n,numsteps,fast,slow,i,additive,g]
    )
    return n,numsteps,additive,g

def inside_while_body(n,numsteps,fast,slow,i,additive,g):
    slow = tf.math.mod(tf.math.add(tf.math.multiply(slow,slow),additive),n)
    i = tf.math.add(i,1)
    fast = tf.math.mod(tf.math.add(tf.math.multiply(fast,fast),additive),n)
    fast = tf.math.mod(tf.math.add(tf.math.multiply(fast,fast),additive),n)
    g = gcd(tf.math.subtract(fast,slow),n)
    n,numsteps,i,additive,g = tf.cond(
        tf.math.not_equal(g,1),
        lambda: factorPR_if_body(n,numsteps,i,additive,g),
        lambda: (n,numsteps,i,additive,g)
    )
    return n,numsteps,fast,slow,i,additive,g
def factorPR_if_body(n,numsteps,i,additive,g):
    n,numsteps,i,additive,g = tf.cond(tf.math.equal(g,n),
        lambda:(n,numsteps,numsteps,(tf.math.add(additive,1)),g),
        lambda:(n,numsteps,numsteps,5,g)
        )
    return n,numsteps,i,additive,g