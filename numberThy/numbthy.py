# -*- coding: utf-8 -*-
"""numbthy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zFKorJ2XnXpkVGIpU5_XedMlU4y8SN7s
"""

import tensorflow as tf
import functools
sess = tf.InteractiveSession()
tf.global_variables_initializer()

print(tf.math.pow(32,34).eval())

####################-- gcd function --################

def gcd(a,b):
    '''gcd(a,b) return the greatest common divisor 
    of tensor constant a and b.'''
    a = tf.math.abs(a)
    b = tf.math.abs(b)
    result = tf.while_loop(
        cond,body,[a,b]
    )
    return result[1]
def cond(a,b):
    return tf.math.greater(a, 0)
def body(a,b):
    b = tf.math.floormod(b,a)
    tep = a
    a = b
    b = tep
    return a, b

a1 = tf.constant(2040)
b2 = tf.constant(1071)
h = gcd(a1,b2)


print (h.eval())

####################-- xgcd function --################

def xgcd(a,b):
    """xgcd(a,b) returns a tuple of form (g,x,y), where g is gcd(a,b) and
    x,y satisfy the equation g = ax + by."""
    a1=1; b1=0; a2=0; b2=1; aneg=1; bneg=1; flag=1
    a, aneg = tf.cond(tf.less(a, 0),true_fn= lambda: (tf.math.negative(a), -1), false_fn=lambda:(a, aneg))
    b, bneg = tf.cond(tf.less(b, 0),true_fn=lambda: (tf.math.negative(b), -1), false_fn=lambda:(b, bneg))
    
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.while_loop(
        lambda a,b,a1,b1,a2,b2,aneg,bneg,flag: tf.greater(flag,0),
        body_1,
        [a,b,a1,b1,a2,b2,aneg,bneg,flag]
    )
    res1, res2, res3 = tf.cond(
        tf.math.equal(a, 0),
        true_fn = lambda: (tf.identity(b), tf.math.multiply(a2,aneg), tf.math.multiply(b2,bneg)),
        false_fn = lambda: (tf.identity(a), tf.math.multiply(a1,aneg), tf.math.multiply(b1,bneg))
    )
    return res1, res2, res3

def body_1(a,b,a1,b1,a2,b2,aneg,bneg,flag): 
    quot = tf.math.negative(tf.math.floordiv(a,b))
    a = tf.math.floormod(a, b)
    a1 = tf.math.add(a1, tf.math.multiply(quot,a2))
    b1 = tf.math.add(b1, tf.math.multiply(quot,b2))
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.cond(
        tf.math.equal(a, 0),
        true_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,0),
        false_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,flag)
    )
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.cond(
        tf.math.not_equal(a,0),
        true_fn = lambda: body_2(a,b,a1,b1,a2,b2,aneg,bneg,flag),
        false_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,flag)
    )
    return a,b,a1,b1,a2,b2,aneg,bneg,flag
    
def body_2(a,b,a1,b1,a2,b2,aneg,bneg,flag):
    quot = tf.math.negative(tf.math.floordiv(b,a))
    b = tf.math.floormod(b, a)
    a2 = tf.math.add(a2, tf.math.multiply(quot,a1))
    b2 = tf.math.add(b2, tf.math.multiply(quot,b1))
    a,b,a1,b1,a2,b2,aneg,bneg,flag = tf.cond(
        tf.math.equal(b, 0),
        true_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,0),
        false_fn = lambda:(a,b,a1,b1,a2,b2,aneg,bneg,flag)
    )
    return a,b,a1,b1,a2,b2,aneg,bneg,flag

a1 = tf.constant(65)
b2 = tf.constant(78)
a1 = tf.constant(4)
b2 = tf.constant(2)
h,v,f = xgcd(a1,b2)
print(h.eval(),v.eval(),f.eval())

l = tf.bitwise.right_shift(3,1)
print(l.eval())
p = ((4>>1) & 1)
print(p)
j = tf.bitwise.bitwise_and(2,9)
print(j.eval())

####################-- power_mod function --################

def power_mod(b,e,n):
    accum,i,bpow2 = tf.cond(
        tf.math.less(e,0),
        true_fn = lambda: (inverse_mod(b, n), tf.math.negative(e), n),
        false_fn = lambda: power_mod_cond_body(b,e,n)
    )
    return accum

def power_mod_cond_body(b,e,n):
    accum = 1; i = 0; bpow2 = b
    b,e,n,accum,i,bpow2 = tf.while_loop(
        lambda b,e,n,accum,i,bpow2: tf.greater(tf.bitwise.right_shift(e,i),0),
        power_mod_while_body,
        [b,e,n,accum,i,bpow2]
    )
    return accum,i,bpow2

def power_mod_while_body(b,e,n,accum,i,bpow2):
    b,e,n,accum,i,bpow2 = tf.cond(
        tf.math.equal(tf.bitwise.bitwise_and(tf.bitwise.right_shift(e,i),1),1),
        true_fn = lambda: power_mod_cond_body_1(b,e,n,accum,i,bpow2),
        false_fn = lambda: (b,e,n,accum,i,bpow2)
    )
    bpow2 = tf.math.floormod(tf.math.multiply(bpow2,bpow2),n)
    i = tf.math.add(i,1)
    return b,e,n,accum,i,bpow2

def power_mod_cond_body_1(b,e,n,accum,i,bpow2):
    accum = tf.math.floormod(tf.math.multiply(accum,bpow2),n)
    return b,e,n,accum,i,bpow2

####################-- inverse_mod function --################

def inverse_mod(a,n):
    (g,xa,xb) = xgcd(a,n)
    result = tf.cond(
        tf.math.not_equal(g,1),
        true_fn = lambda: -1,
        false_fn = lambda: tf.math.floormod(xa,n)
    )
    return result

a = inverse_mod(4,7)
print(a.eval())

print(power_mod(4,3,2).eval())
print(power_mod(4,7,9).eval())

print(power_mod(1,6,4).eval())
print(power_mod(9,15,3).eval())

####################-- is_prime function --################

def is_prime(n):
    result = 1; 
    n = tf.cond(tf.math.less(n,0), lambda:tf.math.negative(n), lambda: n)
    result = tf.cond(
        tf.math.less(n,2), 
        lambda: tf.math.subtract(result,1), 
        lambda :is_prime_cond_body(n)
        )
    result = tf.math.equal(result, 1)
    return result

def is_prime_cond_body(n):
    check_list = tf.math.equal(n,(2,3,5,7,11,13,17,19,23,29))
    has_true, id_check_list = tf.unique(check_list)
    size = tf.size(has_true)
    result = tf.cond(tf.math.equal(size,2), lambda: 1, lambda: check_isprimeE(n))
    return result
    
def check_isprimeE(n):
    result = tf.logical_and(tf.logical_and(isprimeE(n,2), isprimeE(n,3)),isprimeE(n,5))
    result = tf.cond(tf.math.equal(result, True),lambda:1, lambda:0)
    return result

print(is_prime(2).eval())
print(is_prime(15).eval())
print(is_prime(27).eval())

####################-- factor function --################

@tf.function
def factor(n):
	"""factor(n) - Return a sorted list of the prime factors of n with exponents."""
	# Rewritten to align with SAGE.  Previous semantics available as factors(n).
	if ((abs(n) == 1) or (n == 0)): raise ValueError('Unable to factor {0}'.format(n))
	factspow = []
	currfact = None
	for thefact in factors(n):
		if thefact != currfact:
			if currfact != None:
				factspow += [(currfact,thecount)]
			currfact = thefact
			thecount = 1
		else:
			thecount += 1
	factspow += [(thefact,thecount)]
	return tuple(factspow)

print(factors(4)[0].eval())
print(factors(4)[1].eval())
print(factor(4)[0][0].eval())
print(factor(4)[0][1].eval())
print(factor(4)[1][0].eval())
print(factor(4)[1][1].eval())

####################-- prime_divisors function --################

def prime_divisors(n):
    return tuple(set(factors(n)))

####################-- euler_phi function --################

def euler_phi(n):
    result = 1
    for i in range(2,n):
        result = tf.cond(tf.math.equal(gcd(i,n),1),lambda:tf.math.add(result,1),lambda: tf.math.add(result,0))
    return result

print(euler_phi(9).eval())

####################-- def carmichael_lambda function --################

def carmichael_lambda(n):
    f = [-1]
    f = tf.tuple(f)
    i = 1
    f,i,n= tf.while_loop(
        lambda i,f,n: tf.math.less(i,n),
        body1,
        [f,i,n]
    )
    return f
def body1(f,i,n):
    f,i,n = tf.cond(tf.math.equal(gcd(i,n),1), lambda:bbb(f,i,n),lambda:(f,i,n))  
    return f,i,n

def bbb(f,i,n):
    print("here")
    print(f)
    f.append(i)
    i = tf.math.add(i,1)
    return f,i,n

g = carmichael_lambda(5)
print(g[0].eval())
print(g[1].eval())
print(g[2].eval())
print(g[3].eval())

####################-- is_primitive_root function --################



####################-- sqrtmod function --################

def sqrtmod(a,n):
	"""sqrtmod(a,n) - Compute sqrt(a) mod n using various algorithms.
	Currently n must be prime, but will be extended to general n (when I get the time)."""
	# SAGE equivalent is mod(g,n).sqrt() in IntegerMod class
	if(not isprime(n)): raise ValueError("*** Error ***:  Currently can only compute sqrtmod(a,n) for prime n.")
	if(pow(a,(n-1)//2,n)!=1): raise ValueError("*** Error ***:  a is not quadratic residue, so sqrtmod(a,n) has no answer.")
	return TSRsqrtmod(a,n-1,n)

####################-- TSRsqrtmod function --################

def TSRsqrtmod(a,grpord,p):
    ordpow2=0; non2=grpord; temp_g=0; one = 1
    ordpow2,non2 = tf.while_loop(
        lambda ordpow2,non2: tf.math.logical_not(tf.math.equal(tf.bitwise.bitwise_and(non2,0x01),1)),
        TSRsqrtmod_while,
        [ordpow2,non2]
    )
    for g in range(2,grpord-1):
        g, grpord, p,temp_g,one = tf.cond(
            tf.math.not_equal(tf.math.mod(tf.math.pow(g,tf.math.floordiv(grpord,2)),p),one),
            lambda:save_temp(g,grpord,p,temp_g,one),
            lambda:(g,grpord,p,temp_g,one)
            )
    
    g = tf.math.mod(tf.math.pow(g,tf.math.floordiv(non2,2)),p)
    gpow=0; atweak=a
    #tf.math.add(ordpow2,1)
    for pow2 in range(0,ordpow2.eval()-1):
        
        g,gpow,pow2,atweak,p = tf.cond(
            tf.math.not_equal(tf.math.mod(tf.math.pow(atweak,tf.math.multiply(tf.math.pow(2,tf.math.subtract(ordpow2,pow2)),non2)),p),1),
            lambda:TSRsqrtmod_true(g,gpow,pow2,atweak,p),
            lambda:(g,gpow,pow2,atweak,p)
        )

    d = inverse_mod(2,non2)
    tmp = tf.math.mod(tf.math.pow(g,gpow),p)
    tmp = tf.math.mod(tf.math.pow(tf.math.multiply(a,tmp),d),p)
    result = tf.math.floormod(tf.math.multiply(tmp,inverse_mod(tf.math.floormod(tf.math.pow(g,tf.math.floordiv(gpow,2)),p),p)),p)
    return result

def TSRsqrtmod_while(ordpow2,non2):
    ordpow2 = tf.math.add(ordpow2,1)
    non2 = tf.math.floordiv(non2,2)
    return ordpow2,non2

def save_temp(g,grpord,p,temp_g,one):
    temp_g = g;
    return g,grpord,p,temp_g,(tf.math.mod(tf.math.pow(g,tf.math.floordiv(grpord,2)),p))

def TSRsqrtmod_true(g,gpow,pow2,atweak,p):
    gpow = tf.math.add(gpow,tf.math.pow(tf.math.subtract(pow2,1),2))
    atweak = tf.math.multiply(atweak,tf.math.mod(tf.math.pow(g,tf.math.pow(2,tf.math.subtract(pow2,1))),p))
    return g,gpow,pow2,atweak,p

print(TSRsqrtmod(9,4,5).eval())
print(pow(3,8000//2,2))

f = range(2,6)
print(f[0])

################ Internally used functions #########################################

####################-- isprimeF function --################

def isprimeF(n,b):
    """
    isprimeF(n,b) - Test whether number n is prime or a Fermat pseudoprime to base b.
    process: (b**(n-1)) % n
    """
    num = tf.math.floormod(tf.math.pow(b, n-1),n)
    return tf.math.equal(num,1)

a = isprimeF(25,3)
print(a.eval())
l = isprimeF(3,4)
print(l.eval())

####################-- isprimeE function --################

def isprimeE(n,b):
    result = 1; flag = 1; c = 0
    n,b,c,result,flag =  tf.cond(
        tf.math.logical_not(isprimeF(n,b)), 
        lambda:(n,b,c,0,flag), 
        lambda:cond_body(n,b,c,result,flag)
        )
    result = tf.math.equal(result, 1)
    return result

def cond_body(n,b,c,result,flag):
    r = tf.math.subtract(n,1)
    r = tf.while_loop(lambda r: tf.math.equal(tf.math.floormod(r,2), 0),
                      lambda r:tf.math.floordiv(r,2),
                      [r])
    c = tf.math.floormod(tf.math.pow(b, r),n)
    n,b,c,result,flag = tf.cond(
        tf.math.equal(c, 1), 
        true_fn = lambda:(n,b,c,1,flag), 
        false_fn = lambda: while_loop(n,b,c,result,flag)
        )
    return n,b,c,result,flag

def while_loop(n,b,c,result,flag):
    n,b,c,result,flag = tf.while_loop(
        lambda n,b,c,result,flag: tf.greater(flag,0),
        while_body,
        [n,b,c,result,flag]
    )
    return n,b,c,result,flag

def while_body(n,b,c,result,flag):
    n,b,c,result,flag = tf.cond(
        tf.math.equal(c,1),
        true_fn = lambda: (n,b,c,0,0),
        false_fn = lambda: while_body_1(n,b,c,result,flag)
        )
    return n,b,c,result,flag

def while_body_1(n,b,c,result,flag):
    n,b,c,result,flag = tf.cond(
        tf.math.equal(c,n-1),
        true_fn = lambda: (n,b,c,1,0),
        false_fn = lambda: (n,b,(tf.math.floormod(tf.math.pow(c, 2),n)),result,flag)
        )
    return n,b,c,result,flag

a = isprimeE(25,3)
print(a.eval())
a = isprimeE(15,4)
print(a.eval())
a = isprimeE(3,4)
print(a.eval())

####################-- factorone function --################

def factorone(n):
    fact = -1
    n, fact= tf.cond(is_prime(n), lambda:(n, n), lambda:factorone_cond_body(n,fact))
    fact = tf.cond(tf.math.equal(0,tf.math.mod(n,fact)),lambda:fact,lambda:factorPR(n))
    return fact

def factorone_cond_body(n,fact):
    fact_list = [2,3,5,7,11,13,17,19,23,29]
    size = len(fact_list)
    index = 0
    n,fact,index,size,fact_list = tf.while_loop(
        lambda n,fact,index,size,fact_list: tf.math.less(index,10),
        factorone_while_body,
        [n,fact,index,size,fact_list]
        )
    return n,fact
    
def factorone_while_body(n,fact,index,size,fact_list):
    n,fact,index,size,fact_list = tf.cond(
        tf.math.equal(tf.math.mod(n,tf.gather(fact_list,index)),0),
        lambda: (n,tf.gather(fact_list,index),size,size,fact_list),
        lambda: (n,fact,tf.math.add(index,1),size,fact_list)
        )
    return n,fact,index,size,fact_list

print(factorone(75).eval())

####################-- factors function --################

def factors(n):
    i = 2
    factors = []
    while i * i <= n:
        
        if n % i:
            print(n%i)
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

print(factors(98))

def factors(n):
    i = 2
    factors = tf.tuple([-1])
    tf.while_loop(
        lambda i,n,factars: tf.math.less_equal(tf.math.multiply(i,i),n),
        factors_while_body,
        [i,n,factors]
    )
    i, n, factors = tf.cond(tf.math.greater(n,1), lambda:facts_cond_body(i,n,factors),lambda:(i,n,factors))
    return factors

def factors_while_body(i,n,factors):
    print(factors)
    i,n,factors = tf.cond(tf.math.greater_equal(tf.math.floormod(n,i),1), lambda:cccc(i,n,factors),lambda:while_cond_body(i,n,factors))
    print("kkkkk")
    return i,n,factors

def cccc(i,n,factors):
    i = tf.math.add(i,1)
    
    return i,n,factors
    
def while_cond_body(i,n,factors):
    print(factors)
    factors.append(i)
    n = tf.math.floordiv(n,i)
    #
    print(factors)
    return i,n,factors

def facts_cond_body(i,n,factors):
    factors.append(n)
    print(factors)
    return i, n, factors

print(factors(4))

fact = [-1];
fact =tf.convert_to_tensor(fact,tf.int32)
a = [fact]+[[tf.constant(5)]]+[[tf.constant(4)]]
a = tf.convert_to_tensor(a)
print(a.shape)
a = tf.reshape(a,[1,3])
print(a.eval())

a = tf.tuple([1,6,5])
b = tf.tuple([9])
c = a+b
c = tf.sort(c)
#print(c[0].eval())
#print(c[1].eval())
#print(c[2].eval())
#print(c[3].eval())
print(c.eval())

####################-- factorPR function --################

def factorPR(n):
    numsteps = tf.math.multiply(2.,tf.math.floor(tf.math.sqrt(tf.math.sqrt(tf.dtypes.cast(n,tf.float32)))))
    numsteps = tf.dtypes.cast(numsteps,tf.int32)
    additive = 1; g = -1; result = 0;
    n,numsteps,additive,g = tf.while_loop(
        lambda n,numsteps,additive,g: tf.math.less(additive,5),
        factorPR_while_body,
        [n,numsteps,additive,g]
    )
    result = tf.cond(tf.math.equal(additive,4),lambda:1,lambda:g)
    return result

def factorPR_while_body(n,numsteps,additive,g):
    fast=slow=1; i=1; 
    n,numsteps,fast,slow,i,additive,g = tf.while_loop(
        lambda n,numsteps,fast,slow,i,additive,g: tf.math.less(i,numsteps),
        inside_while_body,
        [n,numsteps,fast,slow,i,additive,g]
    )
    return n,numsteps,additive,g

def inside_while_body(n,numsteps,fast,slow,i,additive,g):
    slow = tf.math.mod(tf.math.add(tf.math.multiply(slow,slow),additive),n)
    i = tf.math.add(i,1)
    fast = tf.math.mod(tf.math.add(tf.math.multiply(fast,fast),additive),n)
    fast = tf.math.mod(tf.math.add(tf.math.multiply(fast,fast),additive),n)
    g = gcd(tf.math.subtract(fast,slow),n)
    n,numsteps,i,additive,g = tf.cond(
        tf.math.not_equal(g,1),
        lambda: factorPR_if_body(n,numsteps,i,additive,g),
        lambda: (n,numsteps,i,additive,g)
    )
    return n,numsteps,fast,slow,i,additive,g
def factorPR_if_body(n,numsteps,i,additive,g):
    n,numsteps,i,additive,g = tf.cond(tf.math.equal(g,n),
        lambda:(n,numsteps,numsteps,(tf.math.add(additive,1)),g),
        lambda:(n,numsteps,numsteps,5,g)
        )
    return n,numsteps,i,additive,g

